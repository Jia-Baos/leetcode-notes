# 01.02.04 练习题目（第 04 天）

## 1. [0048. 旋转图像](https://leetcode.cn/problems/rotate-image/)

### 1.1 题目大意

**描述**：给定一个 `n * n` 大小的二维矩阵（代表图像）`matrix`。

**要求**：将二维矩阵 `matrix` 顺时针旋转 90°。

**说明**：

- 不能使用额外的数组空间。
- $n == matrix.length == matrix[i].length$。
- $1 \le n \le 20$。
- $-1000 \le matrix[i][j] \le 1000$。

**示例**：

```Python
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

```Python
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)

```C++
#include <bits/stdc++.h>

int main(int argc, char *argv[])
{
    std::array<std::array<int, 3>, 3> arr =
        {{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}};

    for (size_t i = 0; i < arr.size() / 2; i++)
    {
        for (size_t j = i; j < arr[0].size() - 1 - i; j++)
        {

            int temp = arr[i][j];
            arr[i][j] = arr[arr.size() - j - 1][i];
            arr[arr.size() - j - 1][i] =
                arr[arr.size() - i - 1][arr.size() - j - 1];
            arr[arr.size() - i - 1][arr.size() - j - 1] =
                arr[j][arr.size() - i - 1];
            arr[j][arr.size() - i - 1] = temp;
        }
    }

    for (auto &iter1 : arr)
    {
        for (auto &iter2 : iter1)
        {
            std::cout << iter2 << std::endl;
        }
    }

    return 0;
}
```

## 2. [0054. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

### 2.1 题目大意

**描述**：给定一个 `m * n` 大小的二维矩阵 `matrix`。

**要求**：按照顺时针旋转的顺序，返回矩阵中的所有元素。

**说明**：

- $m == matrix.length$。
- $n == matrix[i].length$。
- $1 \le m, n \le 10$。
- $-100 \le matrix[i][j] \le 100$。

**示例**：

```Python
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```Python
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```C++
#include <bits/stdc++.h>

int main(int argc, char *argv[])
{
    std::array<std::array<int, 3>, 3> arr1 =
        {{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}};

    int up = 0;
    int left = 0;
    int down = arr1.size() - 1;
    int right = arr1[0].size() - 1;

    std::array<int, arr1.size() * arr1[0].size()> arr2;

    int flag = 0;
    while (true)
    {
        for (int i = left; i < right + 1; i++)
        {
            arr2[flag++] = arr1[up][i];
        }
        up += 1;

        if (up > down)
        {
            break;
        }

        for (int i = up; i < down + 1; i++)
        {
            arr2[flag++] = arr1[i][right];
        }

        right -= 1;

        if (left > right)
        {
            break;
        }

        for (int i = right; i > left - 1; i--)
        {
            arr2[flag++] = arr1[down][i];
        }

        down -= 1;
        
        if (up > down)
        {
            break;
        }

        for (int i = down; i > up - 1; i--)
        {
            arr2[flag++] = arr1[i][left];
        }

        left += 1;

        if (left > right)
        {
            break;
        }
    }

    for (auto &iter : arr2)
    {
        std::cout << iter << std::endl;
    }

    return 0;
}
```

## 3. [0498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/)

### 3.1 题目大意

**描述**：给定一个大小为 `m * n` 的矩阵 `mat` 。

**要求**：以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。

**说明**：

- $m == mat.length$。
- $n == mat[i].length$。
- $1 \le m, n \le 10^4$。
- $1 \le m * n \le 10^4$。
- $-10^5 \le mat[i][j] \le 10^5$。

**示例**：

```Python
输入：mat = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,4,7,5,3,6,8,9]
```

![](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)

```C++
#include <bits/stdc++.h>

int main(int argc, char *argv[])
{
    std::array<std::array<int, 3>, 3> arr1 =
        {{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}};

    int up = 0;
    int left = 0;
    int down = arr1.size() - 1;
    int right = arr1[0].size() - 1;

    std::array<int, arr1.size() * arr1[0].size()> arr2;

    int row = 0;
    int col = 0;
    int flag = 0;
    for (size_t i = 0; i < arr2.size(); i++)
    {
        arr2[flag++] = arr1[row][col];

        if ((row + col) % 2 == 0)
        {
            if (col == arr1[0].size() - 1)
            {
                row++;
            }
            else if (row == 0)
            {
                col++;
            }
            else
            {
                row--;
                col++;
            }
        }
        else
        {
            if (row == arr1.size() - 1)
            {
                col++;
            }
            else if (col == 0)
            {
                row++;
            }
            else
            {
                row++;
                col--;
            }
        }
    }

    for (auto &iter : arr2)
    {
        std::cout << iter << std::endl;
    }

    return 0;
}
```
